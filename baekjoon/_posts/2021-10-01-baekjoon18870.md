---
layout: post
title: Baekjoon 18870 좌표 압축
subtitle: 백준 18870 좌표 압축
gh-repo: harley-hwan/harley-hwan.github.io
gh-badge: [star, fork, follow]
tags: [baekjoon, 백준, algorithm, sort]
comments: true
---

# Baekjoon 18870 좌표 압축

- 최초 작성일: 2021년 10월 1일(금)
- 주소: https://www.acmicpc.net/problem/18870

## 목차
[TOC]

## 문제 설명
![image-20211001200050695](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20211001200050695.png)


- 수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.
- Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.
- X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.

## 입력
- 첫째 줄에 N이 주어진다.
- 둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.

## 출력

- 첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.


![image-20211001200136566](C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20211001200136566.png)


## 알고리즘 분류

- 정렬
- 값 / 좌표 압축

## 풀이 방법

<<<<<<< HEAD
- 이 문제는 주어지는 숫자들을 정렬하며 작은 순으로 순서를 매겨주면 되는 문제다.
- 하지만, 주어진 입력 순서 그대로 다시 출력해주어야 하기 때문에 정렬 하기 전 해당 숫자의 인덱스를 기억해줘야 한다.
- 그래서 2중 벡터(v)에 입력을 넣을 때 인덱스를 같이 저장해둔다.
- 그러고 난뒤 입력값을 기준으로 오름차순으로 정렬해주고, 인접한 숫자와 같은지를 비교해 같지 않으면 cnt를 1씩 증가시키고 같으면 현재 cnt 값 그대로를 새로운 이중 벡터(order)에 이전에 저장했던 인덱스와 함께 저장한다. 
- 마지막으로, order 벡터의 second값(입력 순서를 기억하는 인덱스값)을 기준으로 오름차순 해주고 그대로 출력하면 된다.
=======
- 문제는 간단했고, 그것을 어떻게 표현하고 구현하느냐가 중요한 문제이다.

##### 1. 산술평균
 - 그냥 평균 구하면 된다. 합 구해서 / n 해줬다. 대신, 첫 째자리 수에서 반올림 해줘야 하므로, float 형식으로 합을 받아 n 을 나누고 round 함수로 반올림 해주었다.

##### 2. 중앙값:
 - 증가하는 순서로 나열했을 때 그 중앙에 위치하는 값이다. 여기서, "증가하는 순서로 나열" 말 그대로 오름차순으로 정렬해주고 거기서 인덱스 n/2 인 곳의 수를 출력해준다

##### 3. 최빈값
 - 이게 제일 까다로웠다. 가장 빈도수가 많은 숫자를 출력하되, 중복이 있다면 두번째로 작은 것을 출력해야 한다. 즉, 세번째부터는 고려하지 않아도 된다라는 것이다. 
 - 그러면 처음 숫자와 바로 인접한 수를 비교하면서 같으면 count를 1증가하고, 또 그 다음 인접한 수를 비교하는 것을 반복하다가, 같지 않으면 해당 반복되는 숫자와 반복된 횟수를 make_pair로 쌍을 만들어 vfreq라는 새로운 2차원 벡터에 넣어준다. 
 - 그런 다음, count를 초기화하고 다음 것부터 다시 비교를 시작하고 방금 했던 걸 반복한다.
 - 그 다음 vfreq를 count(반복횟수) 순으로 내림차순, count(반복횟수)가 같을 시 v[i](반복되는 숫자) 숫자 순으로 오름차순 해준다.
 - 왜냐하면, 같을 때 두번째 작은 숫자를 출력하라했기 때문에, 위에서 말한 것처럼 정렬한 후 vfreq 벡터에서 두번째 인덱스(1번 인덱스)의 반복되는 숫자(first)를 출력한다.
 - 대신 같은게 없다면, 첫번째 인덱스(0번 인덱스)의 반복되는 숫자(first)를 출력한다.

##### 4. 범위
 - 마지막으로, 범위는 그냥 오름차순 된 숫자들 중 가장 마지막 인덱스의 숫자와 가장 처음 인덱스의 숫자를 뺀 것을 출력한다.



---
>>>>>>> 7de16531549ec16c20e89088102ce6fd35c54de5



```c++
#include <iostream>
#include <vector>
#include <map>
#include <algorithm>

using namespace std;

bool compare(const pair<int, int> p1, const pair<int, int> p2)
{
    return p1.second < p2.second;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);

    int n; cin >> n;
    vector<int> x;
    vector<pair<int, int> > v;

    for (int i = 0; i < n; i++) {
        int X; cin >> X;
        v.push_back(make_pair(X,i));
    }

    sort(v.begin(), v.end());

    // for (auto a : v) {
    //     cout << a.first << " " << a.second << "\n";
    // }

    int cnt = 0;
    vector<pair<int, int> > order;

    order.push_back(make_pair(0, v[0].second));

    for (int i = 1; i < v.size(); i++) {
        if (v[i].first != v[i-1].first) {
            cnt++;
            order.push_back(make_pair(cnt, v[i].second));
            continue;
        }
        order.push_back(make_pair(cnt, v[i].second));
    }
    
    sort(order.begin(), order.end(), compare);

    for (auto a : order) {
        cout << a.first << " ";
    }
    return 0;
}
```

